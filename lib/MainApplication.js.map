{"version":3,"sources":["webpack:///webpack/bootstrap 7c137b4fe2c1f45c3dd5","webpack:///external \"babel-polyfill\"","webpack:///./src/main/ts/MainApplication.ts","webpack:///external \"fs\"","webpack:///external \"path\"","webpack:///external \"lodash\"","webpack:///external \"nomnom\"","webpack:///external \"terminal-console\"","webpack:///./src/main/ts/UltiSnippetParser.ts","webpack:///./src/main/ts/VisualStudioConverter.ts"],"names":[],"mappings":"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","file":"lib/MainApplication.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7c137b4fe2c1f45c3dd5","module.exports = require(\"babel-polyfill\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"babel-polyfill\"\n// module id = 1\n// module chunks = 0","import fs = require(\"fs\")\nimport * as path from \"path\"\nimport * as _ from \"lodash\"\n\nimport * as nomnom from \"nomnom\"\nimport {TerminalConsole} from \"terminal-console\"\n\nimport {parseSnippets, UltiSnippet} from \"./UltiSnippetParser\"\nimport {convertToVisualSnippet} from \"./VisualStudioConverter\"\nimport {VisualStudioCodeSnippets} from \"./VisualStudioOutput\" \n\ninterface ParserParameters {\n\tin?: Array<string>\n\tout: string\n\t\n\tfiletype?: string\n\n\t/**\n\t * Extra files on the command line\n\t */\n\t_?: Array<string>\n}\n\nvar console = new TerminalConsole()\n\nvar parameters: ParserParameters = nomnom.option(\"in\", {\n\thelp: \"UltiSnips input file.\",\n\tabbr: \"i\",\n\trequired: false,\n\tlist: true\n}).option(\"out\", {\n\thelp: \"Visual Studio Code output file.\",\n\tabbr: \"o\",\n\trequired: true\n}).option(\"filetype\", {\n\thelp: \"VIM filetype in .format. Will be searched in VIM_ULTISNIPS_FOLDER environment variable location.\",\n\tabbr: \"t\",\n\trequired: false\n}).parse(process.argv)\n\nlet vsSnippets : VisualStudioCodeSnippets = {}\nlet fileNames : Array<string> = []\n\nif (parameters[\"in\"]) {\n\tfileNames.push(...parameters[\"in\"])\n}\n\nif (parameters.filetype) {\n\tconst SNIPPETS_FOLDER = process.env.VIM_ULTISNIPS_FOLDER\n\n\tif (!SNIPPETS_FOLDER) {\n\t\tconsole.error(\"You need to set the VIM_ULTISNIPS_FOLDER environment variable to use the vim filetypes.\")\n\t\tprocess.exit(1)\n\t}\n\n\tparameters.filetype.split(\".\")\n\t\t.map(it => `${path.join(SNIPPETS_FOLDER, it)}.snippets`)\n\t\t.forEach(it => fileNames.push(it))\n}\n\nif (!fileNames.length) {\n\tconsole.error(\"You need to pass in some snippets files to process using the actual \" + \n\t\t\t\t  \"snippets file (with --in) or the VIM file type string using (--filetype).\")\n\tprocess.exit(2)\n}\n\n_(fileNames)\n\t.map(snippetFileName => parseSnippets(snippetFileName,\n\t\t\t\t\t  \t\t\t\t\t  fs.readFileSync(snippetFileName, \"utf-8\"))\n\t)\n\t.flatten()\n\t// we remove the snippets that have regexp for matching\n\t.filter((it : UltiSnippet) => {\n\t\tif (/r/.test(it.flags)) {\n\t\t\tconsole.log(`Removing snippet ${it.macro} since it's an unsupported regexp.`)\n\t\t\treturn false\n\t\t}\n\n\t\treturn true\n\t})\n\t// we sort the items by priority so the same trigger will be overwritten\n\t// by the snippets with higher priority.\n\t.sort((item1: UltiSnippet, item2: UltiSnippet) => item1.priority - item2.priority)\n\t.map((snippet) => convertToVisualSnippet(<any>snippet))\n\t.forEach(snippet => vsSnippets[snippet.prefix] = snippet)\n\t\nvar visualStudioCode = JSON.stringify(vsSnippets, null, 4)\n\nfs.writeFileSync(parameters.out, visualStudioCode, {encoding: \"utf-8\"})\n\n\n\n// WEBPACK FOOTER //\n// ./src/main/ts/MainApplication.ts","module.exports = require(\"fs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 3\n// module chunks = 0","module.exports = require(\"path\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"path\"\n// module id = 4\n// module chunks = 0","module.exports = require(\"lodash\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash\"\n// module id = 5\n// module chunks = 0","module.exports = require(\"nomnom\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"nomnom\"\n// module id = 6\n// module chunks = 0","module.exports = require(\"terminal-console\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"terminal-console\"\n// module id = 7\n// module chunks = 0","import * as path from \"path\"\nimport * as fs from \"fs\"\n\nexport interface UltiSnippet {\n\tmacro: string\n\tdescription: string\n\tcode: Array<string>,\n\tpriority: number,\n\tflags: string\n}\n\nenum ReadState {\n\tBLANK,\n\tSNIPPET_CONTENT\n}\n\nexport function parseSnippets(snippetsFile: string, snippetCode : string) : Array<UltiSnippet> {\n\tvar result : Array<UltiSnippet> = []\n\tvar currentSnippet : UltiSnippet = null\n\tvar state : ReadState = ReadState.BLANK\n\tvar currentPriority = 0\n\t\n\tsnippetCode.split(/\\n/).forEach((line, index) => {\n\t\tif (state == ReadState.BLANK) {\n\t\t\tif (/^\\s*$/.test(line)) {\n\t\t\t\treturn; //=> blank line, nothing to do\n\t\t\t}\n\t\t\t\n\t\t\tif (/^\\s*#.*$/.test(line)) {\n\t\t\t\treturn; //=> comment line, nothing to do.\n\t\t\t}\n\n\t\t\tif (/^priority -?\\d+$/.test(line)) {\n\t\t\t\tcurrentPriority = parseInt(/^priority (-?\\d+)$/.exec(line)[1])\n\t\t\t\treturn; // priority for snippets.\n\t\t\t}\n\n\t\t\tif (/^extends .+?$/.test(line)) {\n\t\t\t\ttry {\n\t\t\t\t\tlet typeExtended = /^extends (.+?)$/.exec(line)[1]\n\t\t\t\t\tvar typeExtendedSnippetFile = path.join(path.dirname(snippetsFile), typeExtended) + \".snippets\"\n\t\t\t\t\tlet extraSnippets = parseSnippets(typeExtendedSnippetFile,\n\t\t\t\t\t\t\t\t\t\tfs.readFileSync(typeExtendedSnippetFile, \"utf-8\"))\n\n\t\t\t\t\tresult.push(...extraSnippets)\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(`Unable to parse: ${typeExtendedSnippetFile} required via ${snippetsFile}:${index + 1} : ${line}`, e)\n\t\t\t\t}\n\n\t\t\t\treturn; // extended types\n\t\t\t}\n\t\t\t\n\t\t\tvar m = /^snippet\\s+(.*)\\s+\"(.*)\"(\\s+(\\w+)\\s*)?$/.exec(line)\n\t\t\tif (m) {\n\t\t\t\tcurrentSnippet = {\n\t\t\t\t\tmacro: m[1],\n\t\t\t\t\tdescription: m[2],\n\t\t\t\t\tcode : [],\n\t\t\t\t\tpriority: currentPriority,\n\t\t\t\t\tflags: m[4]\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tresult.push(currentSnippet)\n\t\t\t\tstate = ReadState.SNIPPET_CONTENT\n\t\t\t\t\n\t\t\t\treturn //=> done\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Error at line: \" + (index + 1) + \", unable to parse: \" + line)\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (state == ReadState.SNIPPET_CONTENT) {\n\t\t\tif (/^endsnippet\\s*$/.test(line)) {\n\t\t\t\tstate = ReadState.BLANK\n\t\t\t\treturn // => done reading snippets\n\t\t\t}\n\t\t\t\n\t\t\tcurrentSnippet.code.push(line)\n\t\t}\n\t})\n\t\n\treturn result\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/main/ts/UltiSnippetParser.ts","\nimport {VisualStudioCodeSnippet} from \"./VisualStudioOutput\"\nimport {UltiSnippet} from \"./UltiSnippetParser\"\n\nexport function convertToVisualSnippet(ultiSnippet : UltiSnippet) : VisualStudioCodeSnippet {\n\tvar resolvedCode = convertCode(ultiSnippet)\n\t\n\tvar result = {\n\t\tprefix : ultiSnippet.macro,\n\t\tdescription: ultiSnippet.description,\n\t\tbody: resolvedCode\n\t}\n\t\t\n\treturn result\n}\n\nexport interface VariablesIndex {\n\t[key: number] : string\n}\n\nfunction convertCode(ultiSnippet : UltiSnippet) : Array<string> {\n\tif (!ultiSnippet.code) {\n\t\tthrow new Error(`Snippet ${ultiSnippet.macro} has no code. (${ultiSnippet})`);\n\t}\n\n\tvar variables : VariablesIndex = detectVariables(ultiSnippet.code)\n\t\n\treturn ultiSnippet.code\n\t\t\t\t.map(replaceVariables(variables));\n}\n\n/**\n * Detect the variables names from a UltiSnips template. The variables\n * are surrounded by brackets for easier replacement.\n */\nfunction detectVariables(code : Array<string>) : VariablesIndex {\n\tlet result: VariablesIndex = {0: \"0\"};\n\t\n\tcode.forEach((line) => {\n\t\tlet matcher, index\n\t\tconst VARIABLE_RE = /\\$\\{(\\d+)\\:(.*?)\\}/g\n\n\t\tdo {\n\t\t\tmatcher = VARIABLE_RE.exec(line)\n\t\t\t\n\t\t\tif (matcher) {\n\t\t\t\tlet index = parseInt(matcher[1])\n\t\t\t\tlet variableName = matcher[2]\n\t\t\t\t\n\t\t\t\tresult[index] = \"{\" + variableName + \"}\"\n\t\t\t}\n\t\t} while (matcher);\n\t})\n\t\n\treturn result\n}\n\n/**\n * Returns a function that replaces the variables from a line of a\n * UltiSnips template, into a line of visual studio code.\n */\nfunction replaceVariables( variables : VariablesIndex ) : (line: string) => string {\n\treturn (line) => line.replace(/\\$(\\d+)/g, function(subString, index) {\n\t\treturn \"$\" + variables[parseInt(index)]\n\t}).replace(/\\$\\{(\\d+)\\:(.*?)\\}/g, function(subString, index, varName) {\n\t\treturn \"$\" + variables[parseInt(index)]\n\t})\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/main/ts/VisualStudioConverter.ts"],"sourceRoot":""}